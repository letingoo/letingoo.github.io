---
layout: post
title: 2017-06-13 Java并发学习-ThreadLocal
---

ThreadLocal提供了线程本地变量，可以保证访问到的变量属于当前线程，每个线程都保存一个变量的副本。当工作于多线程的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供一个这个变量的副本。因此每个线程都可以独立使用自己的变量， 而不用管其他线程。
ThreadLocal对外提供了4个方法， 他们的作用如下：

1. protected T initialValue() : 返回该线程局部变量的初始值。该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。

2. public T get() ： 返回当前线程所对应的线程局部变量的副本， 如果如果当前线程该变量没有赋值， 它将被initialValue方法初始化。

3. public void set(T value) ： 设置当前线程所对应的线程局部变量的值。

4. public void remove() ： 删除当前线程所对应的线程局部变量的值。如果删除后，这个线程局部变量被该线程读取， 会再次调用initialValue方法初始化这个变量。当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。

ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，但是大大减少了线程同步所带来性能消耗（空间换时间），也减少了线程并发控制的复杂度。

如果你定义了一个单实例的java bean，它有若干属性，但是有一个属性不是线程安全的，比如说HashMap。并且碰巧你并不需要在不同的线程中共享这个属性，也就是说这个属性不存在跨线程的意义。那么你不要sychronized
这么复杂的东西，ThreadLocal将是你不错的选择。


还是很不了解ThreadLocal的用法